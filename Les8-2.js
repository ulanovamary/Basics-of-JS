if (!("a" in window)) {
    var a = 1;
}
alert(a);
// a еще не объявлена в глоб. окруж, поэтому undefined


var b = function a(x) {
    x && a(--x);
};
alert(a);
//в переменную б записана ф-я, которая что-то делает, а в итоге выводит ту же а, что и в предыдущем , поэтому undefined


function a(x) {
    return x * 2;
}
var a;
alert(a);
// наконец мы получаем нашу а (ф-юю) во всем лексич. окружении , которая выводит саму себя, и объявляем переменную а. 
//После объявления ф-ии а, 1,2,3 куски ф-ий выведут саму ф-ю а


function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);
// вот тут непонятно. при обычном ф-я должна 10 вывести... но непонятно как это повлияет на вывод.


function a() {
    alert(this);
}
a.call(null);
// переопределится ф-я а, которая вызывалась ранее и в 1-3 кусках alert эта ф-я, this - подразумевает window,  а.call(null) - вызов от нуля, тоже самое что без аргумента,
// поэмоту должен выдать глобальный объект window
// но это всё неточно...